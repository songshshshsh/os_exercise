## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？

段寄存器共16位，前13位是段表索引，第14位是段表选择位，最后两位是表示请求权限级别。

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

符特权级DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。

当前特权级CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。

请求特权级RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。



访问条件：

访问数据段或堆栈段时，要求max {CPL, RPL} ≤ DPL。

3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

压栈内容：eflags, cs, eip, error code。当中断处理时，发生用户态到内核态转换的时候，还要压入ss, esp。

2. 为什么在用户态的中断响应要使用内核堆栈？

因为中断服务例程在内核态下执行，要用到内核堆栈。

3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

interrupt需要关中断，trap不用。如果不作区分，trap的时候可能会丢失外部中断。

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？

eip是指令执行的地址，会随着指令的运行而变化，作为非inline的可以确保输出的eip是当前程序指针的eip

ebp是堆栈栈底指针，写成inline的可以确保不会被编译器优化（其实写成非inline的也可以）

### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？

不是，中断向量表还没有加载。

